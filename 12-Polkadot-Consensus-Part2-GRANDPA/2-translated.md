---
title: '波卡共识 Part 2: GRANDPA'
src: https://zhuanlan.zhihu.com/p/508856740
author: 刘博
snapshot-date: 2022-05-03
---

![](https://polkadot.network/content/images/2019/12/consensus-grandpa@2x-1.png)

在这个系列的介绍中，我概述了一个共识算法帮助计算机网络回答三个问题。GRANDPA 解决了第二个问题。

1. 谁能提出下一个变化？
2. 哪一组修改是最终的？
3. 如果有人违反规则，会发生什么？

GRANDPA 是 Polkadot 的最终性程序。它的目的是决定性地选择规范链。换句话说，GRANDPA 决定哪一组变化是最终的。它自己并不生产区块；相反，GRANDPA 验证器从另一个区块生产模块（我们将在第三部分讨论）导入区块。

将区块的生产和安全分开的好处之一 -- 除了一般的好工程实践之外 -- 是 GRANDPA 不会对它导入的区块施加许多约束。GRANDPA 只要求区块生产系统具有最终的安全性，遵循 GRANDPA 的分叉选择规则，以及区块的头有一个指向其父块的指针。这第三个属性确保了[轻量级客户](https://link.zhihu.com/?target=https%3A//www.parity.io/blog/what-is-a-light-client/)可以跟踪链。

## GRANDPA 协议

GRANDPA 与其他拜占庭容错（BFT）区块链算法不同，验证者对链而不是区块进行投票。该协议以过境方式应用投票，GRANDPA 算法找到具有足够票数的最高区块编号，以视为最终结果。这个过程允许几个区块在一轮中被最终确定。

这最后一部分很重要，因为它消除了阻碍其他区块链最终性程序的瓶颈。GRANDPA 和其他 PBFT 衍生品一样，具有 `O(n^2)` 的复杂性。也就是说，如果你将节点的数量增加一倍，你必须发送四倍的信息。将区块生产作为最终过程的一部分的共识系统使你为每一个区块发送这些消息。通过在另一个模块中隔离区块生产，我们可以以更有效的方式生产区块（对 BABE 来说是 O(n)），并在一个回合中一起最终确定几个区块。

看下面这个例子，请看这些来自 Kusama 节点的日志信息。

```text
Idle (24 peers), best: #664257 (0x706c…76b7), finalized #664253 (0xe4ab…4d2a)
Imported #664258 (0xee71…6321)
Idle (24 peers), best: #664258 (0xee71…6321), finalized #664256 (0x809a…a5d8)
```

注意，在一轮中，GRANDPA 完成了三个区块（664,254 到 664,256）。

![img](https://pic2.zhimg.com/80/v2-cab7116ac703f2bd45f6fb971a9342ad_1440w.jpg)

这是一个例子，说明 GRANDPA 如何在一轮中敲定多个区块，如上面的日志信息所示。左边的深灰色区块之前是最终确定的，验证者（右边的灰点）已经为新一轮的投票发送了投票。还有三个区块有超级多数投票，被最终确定。

## 一个 GRANDPA 轮次

投票者执行以下操作来最终确定新区块：

1. 一个被指定为 "主要" 的节点广播它认为在上一轮中可以最终确定的最高区块。
2. 在等待网络延迟后，每个验证者对其认为应该被最终确定的最高区块进行 `pre-vote`。如果大多数的验证者是诚实的，这个区块应该延长主广播的链。这个新的链可能比上一个最终确定的链长几个区块。
3. 每个验证者根据预投票的集合计算出可以最终确定的最高区块。如果预选票集扩展了上一个最终确定的链，那么每个验证者将向该链投出一个 `pre-commit`。
4. 每个验证者都会等待收到足够多的预投票，以便在新最终确定的链上形成一个提交信息。

与其他拜占庭容错算法（如 PBFT 和 Hotstuff）的一个微妙但重要的区别是，关键路径上没有视图变化。虽然每一轮都会改变主节点，但这种视图的改变只是为了在异步网络条件下开始新的一轮，因此在部分同步网络中，即使不分配主节点，协议也会一直前进。

当协议中的步骤拥有超过三分之二的 `pre-vote` 或来自验证者的 `pre-commit` 时，这些步骤就可以完成。为了具有确定性的最终结果，必须限制验证人集合中的票数。这与具有概率最终性的链不同，后者可以有无限的验证人集。选择投票者集合的方法是在 GRANDPA 协议之外定义的逻辑（见 [Part 4](https://link.zhihu.com/?target=https%3A//polkadot.network/blog/polkadot-consensus-part-4-security/)）。

GRANDPA 支持加权投票。例如，你可以在你的链上实现 GRANDPA，拥有更多质押的验证人获得更多的投票。然而，在 Polkadot 中，所有验证者都有一个单一的、同等权重的投票。这种加权是一个经济决定，以防止小的节点集获得大的网络份额。

## 负责任的安全：当事情出错的时候

GRANDPA 有一个被称为 "accountable safety" 的功能，让验证者对安全违规行为负责。当两个处于不同链中的区块被最终确认时，就会发生安全违规。负责任的安全就像事故发生后的调查。

但首先，两个冲突的链是如何开始达到最终结果的？BFT 系统总是建立在这样的要求上：有问题的验证人的最大数量是总验证人的某个分数 -- 在我们的例子中是三分之一。为了最终确定两个冲突链，验证人集合未能满足这一要求；至少有三分之一的验证人对这两个链进行了投票。

![img](https://pic2.zhimg.com/80/v2-1e53aa844d365c07f618ba4400f91799_1440w.jpg)

在这个例子中，有 10 个验证人，这意味着 3 个是系统可以承受的最大错误验证者数量（f=（10-1）/3）。有了 4 个有问题的验证人（红色）和一个网络分区，每一组诚实的验证人（蓝色）都可以认为不同的区块是最终的。

对两条相互冲突的链进行投票被称为模棱两可 (equivocating)。这是一个普遍承认的事实，即模棱两可是对 BFT 系统的侮辱。在 GRANDPA 中，我们可以发现它。

首先，我们开始询问节点，为什么他们在投票确定第二个区块时不考虑一个区块的最终结果。任何诚实的验证人都应该用一组第二轮的 `pre-vote` 或 `pre-commit` 来回答这个问题，这些 `pre-vote` 或 `pre-commit` 对第二块有大多数。

如果是这样的话，那么我们再问第二个问题。你看到了第一轮的哪些 `pre-vote`？我们实质上是要求他们向其他验证人告密，并透露他们从同行那里得到的所有投票。在这两组投票的某个地方，你会发现投票给两条冲突链的验证人。据推测，他们将受到严厉的惩罚，但这是链的逻辑业务，而不是共识。

如果发生安全故障，那么网络将不得不进行硬分叉，以选择哪个冲突的链是最终的。有了负责任的安全，Polkadot 可以确保实施攻击的验证者受到惩罚，并且不会留在验证者集合中。

## GRANDPA 如何帮助可用性和有效性

还记得上面的日志信息吗？请注意，最终完成的区块比最佳区块晚了两个区块。这种滞后实际上是将区块生产和最终完成区分开来的一个优势。

```text
Idle (24 peers), best: #664258 (0xee71…6321), finalized #664256 (0x809a…a5d8)
```

区块链互操作性系统，包括 Polkadot，有一个数据可用性问题。想象一下，一个 collator 向验证人提交了一个区块，但是其他的 parachain collator 都没有看到它。如果提交该区块的校对者下线了，会发生什么？验证人有责任将完整的区块存储一段时间，以便任何 parachain collator 都可以询问该区块。

验证人应该在投票前执行区块，但我们想确保他们这样做。Polkadot 中存在一些节点，我们称之为渔夫 (fishermen)，负责执行区块并报告任何验证者的不当行为，例如提议将一个无效的 parachain 区块纳入中继链。

我们绝不希望出现这样的情况：我们最终确定了一个无效的区块，或者最终确定了一个验证者无法重构的区块。通过将最终性保持在链头后面的几个区块，我们可以让预付验证区块是否正确，并对验证人的区块可用性提出质疑。

我们一直在讨论如何决定规范链，但这些链的选项从何而来？这就是 BABE 出现的地方。见本系列的 [Part 3](https://link.zhihu.com/?target=https%3A//polkadot.network/blog/polkadot-consensus-part-3-babe/)。

> [1] 相对于 "最终性"，我更喜欢 "安全性" 这个词，因为最终的区块并不是以物理定律的方式确定的。它们是最终的，因为 GRANDPA 这么说。我更喜欢 "安全" 这个词，它比 "最终" 带有更合理的期望。例如，我们认为航空旅行是安全的。但我们都知道，有时飞机会坠毁。此外，当飞机真的坠毁时，我们有一个调查和法律追索的过程，以追究某些方面的责任。